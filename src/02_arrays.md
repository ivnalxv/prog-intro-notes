# Массивы и ссылки

## Введение в массивы
Освежим знания прошлой лекции.
```java
public class ArrayExample {
	public static void main(String[] args) {
		int[] a;
		System.out.println(a);
	}
}
```
Данный код выдаст ошибку компиляции, так как в Java нельзя обращаться к переменным у которых нет значения.

Хорошо, давайте исправим.

```java
int[] a = new int[10];
```
Данный код выведет 
```java
[I@5b480cf9
```
Очевидно, напрямую sout не может вывести содержимое массива. Для этого можно воспользоваться циклом.
```java
int[] a = new int[10];
for (int i = 0; i < a.length; ++i) {
	System.out.println(a[i]);
}
```

```java
0 0 0 0 0 0 0 0 0 0 
```
Возникает вопрос {{---}} всегда ли мы получим 0? Разные языки придерживаются разного мнения по данному вопросу. Java говорит, что при создании массива примитивного типа **все его элементы** инициализируются в каком-то смысле нулями.

Однако не у каждого примитивного типа есть разумный ноль. К примеру ``boolean``. У этого типа есть два значения ``true`` и ``false``, и значением по умолчанию считается ``false``.

Окэй, что будет если мы проинициализируем массив строчек? 

> Предположение:  Это будет пустая строка. Однако пустая строка это не совсем простая штука. Для пустой строки компилятор должен знать что-то про тип строка, однако в Java это не так. В Java есть только одно место в котором специально упоминается тип String особый --- это то, что к нему можно прибавить все, что угодно, и это все, что угодно будет сконкатенировано.

Для строк мы получим ``null``. Это специальное значение, обозначающее *ничего*. Но как это работает? Дело в том, что когда у нас есть строка, это на самом деле не строка, а ссылка на строку. 

Если у нас есть ``String str = "sadstring"``,  то в этом ``str`` строка не хранится ни в какой форме. Она хранится в памяти, а в ``str`` хранится ссылка на эту память.

Так вот, эта ссылка может указывать на *ничего*, говорящее, что никакой ссылки на самом деле нет. Вот это *ничего* и есть ``null``.

Однако сразу же возникает множество вопросов. Сможете ли вы угадать, что выведет данный код?
```java
String[] a = new String[10];  
a[0] = "hello";  
a[1] = a[0];  
a[2] = "hello";  
a[4] = args[0]; // в args[0] передадим "hello". 
  
System.out.println(a[0] == a[1]);  
System.out.println(a[0] == a[2]);  
System.out.println(a[0] == a[3]);
```
```java
true true false
```

Это должно вызывать вопросы. Давайте помедитируем, почему в последнем будет не ``true`` . В первом элементе массива лежит ссылка на ``hello``. И во втором элементе лежит ссылка на ``hello``.  И в третьем элементе тоже.  Но некоторые из них равны, а некоторые нет. Что происходит? 

 1. В ``a[0]`` просто лежит ссылка на ``hello``. Это на самом деле константа, её положили в пулл констант.
 2.  Мы сказали, что ``a[1] = a[0]`` , поэтому оно будет указывать туда же.
 3. Теперь ``a[2]`` . Это было ``hello``, но другое. Однако, здесь произошел нетривиальный поворот --- Java умеет идентифицировать строчные константы, поэтому она не будет хранить две строчные константы с одинаковым ``hello``. Поэтому третий элемент указывает туда же куда и первый со вторым.
 4. Четвертую ссылку взяли из аргументов командной строки. Когда мы их парсим, об этом ``hello`` никто не знает. Это совершенно новое ``hello``, и они не совпадают.

Правила сравнения в Java такие: 

 - Оператор ``==`` сравнивает в Java элементы как ссылки. Если ссылки указывают в одно место, то они равны, если в разные, то нет.
 - Для проверки строчек на истинное равенство по содержимому. Для этого есть метод ``equals``. Он определен у всех классов, другое дело, он не у всех классов разумно работает.

Итого для ссылочных типов есть два типа равенства --- равенство ссылок и равенство значения.

У любого массива есть длина. Может ли она быть равна нулю?
```java
String[] a = new String[0];  
a[0] = "hello";
```

Правильный ответ может, другое дело, что наша программа сломается, так как мы попытаемся залезть в невыделенную нам память и получим **ArrayIndexOutOfBoundsException**.

Также мы можем создавать массив не заранее фиксированного размера. Здесь ``args.length`` --- не константа компиляции,.
```java
String[] a = new String[args.length];
```
А можем ли мы сделать так?
```java
String[] a = new String[-1];
```
Уже нет, так как не понятно, что такое массив с отрицательной длинной. **Заметьте, что это не ошибка компиляции, так как массивы создаются во время исполнения**.

Часто нам хочется задать массив ещё при создании. Тогда нам нужно написать так:
```java
String[] a = new String[] {
	"hello",
	"world",
	"!"
}
```

Теперь другой вопрос. Сможем ли мы сделать так?
```java
String[] a = new String[] {
	"hello",
	a[0],
	"!",
	args[0]
}
```
Нельзя, так как во время создания никакая переменная ``a`` еще не определена.

Теперь посмотрим на метод ``equals``. 
```java
String[] a = new String[] {  
        "hello",  
        null  
};  
System.out.println(a[0].equals("hello"));  
System.out.println(a[0].equals(null));
```
```java
true
false
```
Существующие строчки не считают себя равными не существующим. Однако какое у нас мнение у ``null`` на эту тему?

```java
String s = null;
System.out.println(s.equals(null));
```
Java выдаст нам **NullPointerException**, так как мы пытаемся вызвать метод у *ничего*. (*Забавно*: Не смотря на то, что в Java везде используется обозначение **reference**, по историческим причинам это исключение называется **PointerException**.)

Дальше так как итерация по индексу для массива --- это очень частое действие, то для этого было создано сокращение:
```java
for (String s : a) {  
    System.out.println(s);  
}
```
Такой синтаксис называется ``foreach``.  Для массивов у нас всегда есть неявный индекс, просто в ``s`` всегда кладётся соответствующий элемент. В случае строчек это ссылка, в случае примитивного массива элемент.


## Двумерные массивы 

В отличии от одномерных, двумерные массивы инициализируются с помощью двух пар квадратных скобочек. Как вы наверное догадались, $n$-мерный массив инициализируются с помощью $n$ пар. 
```java
int[][] ints = new int[2][3];  
  
System.out.println(ints);  
for (int[] v : ints) {  
    System.out.println(v);  
}
```
На самом деле в Java двухмерный массив --- это всего-навсего куча ссылок на одномерные массивы. Мы можем в этом убедиться сделав частично инициализированный массив.

```java
int[][] ints = new int[10][];  

for (int[] row : ints) {  
    for (int elem : row) {
		System.out.print(elem + " ");
	}
	System.out.println();
}
```

В результате в консоль выведется ``10 null``, а потом вылетит исключение, так как мы пытаемся итерироваться по ``null``. Это значит, что ``row`` --- это честная ссылка. Отсюда следует, что двумерный массив не обязан быть прямоугольным, так как ``ints[i]``  это всего лишь ссылка на какой-то массив, без какого-то ограничения на длину. Может быть что-то вроде такого:


>ints[][] a = new int[][]{
>  {1, 2, 3, 4},
>  {1, 2},
>  {0, 1, 3} 
>  };

Но вот так уже сделать нельзя:
```java
int[][] ints = new int[][10];  
```

## Сравнение, массивы как ссылки

Массивы можно сравнивать. Во первых их можно сравнить на ``==``. Если это одна и та же ссылка, то ок, иначе нет. Метод ``equals`` на массивах работает **точно также**, как и ``==`` по определению. Он не будет проверять на равенство элементов.

Так как массивы это по сути ссылки на элементы, то при приравнивании массивов, мы просто будем ссылаться на ту же память.

```java
int[] a = new int[] {1, 2, 3, 4};
int[] b = a;   
System.out.println(a == b);
b[0] = 100;
System.out.print(a[0] + " " + b[0]);
```
```java
true 100 100
```
Ожидаемый результат, так как это ссылки. Но у нас возникает проблема:
```java
int[] a = new int[] {1, 2, 3, 4};  
int[] b = new int[] {1, 2, 3, 4};  
System.out.println(a == b);  
System.out.println(a.equals(b));
```
```java
false false
```

Но так как это ссылки, то два массива с одинаковыми элементами, но разной памятью будут не равны!  Именно поэтому нужно быть аккуратным.

## Функции и массивы

Давайте заведём функцию ``dump()``:
```java
public static void dump(int[] ints) {  
    for (int v : ints) {  
        System.out.print(v + " ");  
    }  
    System.out.println();  
}
```

Что же мы передаем в функцию ``dump()``? Как вы уже наверное догадались, мы передаем *ссылку* на массив. Давайте теперь провернем фокус:
```java
public static void change1(int[] ints) {  
    ints = new int[] {-1, 0};
    dump(ints);
}

public static void change2(int[] ints) {  
    ints[0] = -1;
    dump(ints);
}

public static void main(String[] args) {  
    int[] a = new int[] {1, 2, 3, 4}; 
    int[] b = new int[] {1, 2, 3, 4}; 
    change1(a);
    dump(a);
    System.out.println("========");
    change2(b);
    dump(b);
}
```
```java
-1 0 
1 2 3 4 
========
-1 2 3 4 
-1 2 3 4 
```

Что же тут произошло? Давайте разбираться!
Мы передаём ссылку в ``change1()``. Дальше мы создаем новый массив и наша ссылка начинает указывать на совершенно новое место в памяти. Оно никак не связано со старым, поэтому ``a`` никак не меняется.

Перед тем как поговорить про то, что происходит в ``change2()``, давайте поговорим про типы передачи данных в языках программирования. Есть два основных типа передачи:

 1. По значению (*by value*). При передаче по значению, создаётся копия передаваемого аргумента. Это независимая копия, другая память.
 2. По ссылке. (*by reference*). В таком случае передаётся ссылка на аргумент --- это то же самое место в памяти, поэтому если вы меняете что-то переданное *by reference* исходники изменяются.

В Java аргументы всегда передаются по значению. Поэтому когда мы передаём ссылку в ``change2()``, то мы получаем *копию ссылки*. Однако эта копия всё ещё указывает на то же место в памяти, что и оригинал. Поэтому, когда мы меняем какой-то элемент ``ints``, то мы меняем память принадлежащую массиву ``b``.

Это значит, что на один и тот же объект может быть множество ссылок. Иногда можно словить с этим проблему:
```java
public static void change(int[] x, int[] y) {  
    x[0] = y[1];  
    x[1] = y[0];  
}  
  
public static void main(String[] args) {  
    int[] a = new int[] {10, 30};  
    change(a, a);  
    dump(a);  
}
```
```java
30 30
```
Что здесь произошло? Программист не учел, что в функцию ``change()`` мы можем запихнуть один и тот же массив, и в результате произошла ошибка. С этим нужно быть аккуратным. Это называется **Aliasing** --- когда два, вроде независимых объекта, ссылаются на одно и то же место в памяти. Если они ссылаются на что-то неизменяемое, то все отлично, это никак не может навредить нам ни при каких условиях. Если же там можно что-то поменять, то у вас может возникнуть проблема. Что делать? С этим нужно просто научиться жить 🙂.

Давайте посмотрим на следующий код:
```java
public static int[] create(int value, int len) {  
    int[] result = new int[len];  
    for (int i = 0; i < len; ++i) {  
        result[i] = value;  
    }
    return result;  
}
```
Код создаст нам массив длины ``len``, состоящий из ``value``. Заметим, что ``foreach`` цикл здесь не подойдет, так как мы каждый раз получаем копию элемента, а не ссылку на него. 

Однако вот такой код уже сработает:
```java
Vector[] result = new Vector[] {  
        new Vector(0, 0),  
        new Vector(-40, 30),  
        new Vector(8, 4)  
};  
for (Vector s : result) {  
    s.plus(new Vector(5, -5));  
}  
for (int i = 0; i < result.length; ++i) {  
    System.out.println(result[i]);  
}
```
```java
Vector{x=5.0, y=-5.0}
Vector{x=-35.0, y=25.0}
Vector{x=13.0, y=-1.0}
```

## Копия элементов, System.arraycopy(...)

```java
int[] a = create(10, 5);  
a[1] = 100;  
int[] b = new int[] {0, 10, 20, 30, 40, 50};  
dump(a);  
dump(b);  
System.arraycopy(a, 1, b, 2, 3);  
dump(b);
```
```java
10 100 10 10 10 
0 10 20 30 40 50 
0 10 100 10 10 50 
```

Для ``System.arraycopy(a, b, c, d, e)`` первым параметром является **массив источник**, вторым --- **позиция его начала массива**, третьим --- **массив назначение**, четвертым --- **позиция уже его начала**, пятым --- **сколько элементов**.  (Или можно нормально прочитать в [доках](https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int))) 

Заметим, что если это массив **ссылочного** типа, то будут копироваться *ссылки*, а не значения. Также, если ввести больше чем есть элементов, то получим **ArrayIndexOutOfBoundsException**.

## Дерево пакетов

Как мы уже говорили в начале лекции, хотелось бы уметь выводить массивы. Для этого есть специальный метод!
```java
int[] a = create(10, 5);  
System.out.println(java.util.Arrays.toString(a));
```
```java
[10, 10, 10, 10, 10]
```
Даже больше, можно написать вот так!
```java
int[] a = create(10, 5);  
java.lang.System.out.println(java.util.Arrays.toString(a));
```
```java
[10, 10, 10, 10, 10]
```


Но, прямо скажем, писать всё это очень запарно. В принципе, в этом нет ничего плохого, просто писать так --- не удобно. Так вот, что на самом деле здесь происходит: в Java есть, так называемое **Дерево пакетов**. Это реально дерево, в нем есть пакеты, а в пакетах есть классы и другие пакеты.

Что тут происходит? Сейчас мы знаем, что есть пакет ``java``, в нём пакет ``lang``, а в нём класс ``System``. В этом же пакете ``lang`` находится строка, а вот ``Arrays`` уже находится не в пакете ``lang``, а в пакете ``util``.

В целом, в ``lang`` обычно находятся всякие основные, стандартизированные классы, в ``util`` всякие разные полезные классы. Дерево не обязательно глубины два --- к примеру есть пакет ``java.util.zip``.

Возникают вопросы --- это конечно хорошо, что вместо ``java.lang.System`` можем просто писать ``System``, а можем ли мы вместо ``java.util.Arrays`` просто писать ``Arrays``? Можем, но для этого нам нужно в явной форме импортировать:

```java
import java.util.Arrays;  
  
public class ArrayExample {  
    public static void main(String[] args) {  
        int[] a = new int[] {1, 2, 3};  
        java.lang.System.out.println(Arrays.toString(a));  
    }  
}
```

Правда опять возникает вопрос --- почему для ``Arrays`` нужен импорт, а для всего остального не надо? **Потому что в спецификации написано, что в начале каждой программы импортируется все из ``java.lang``**. Просто прикол пакета ``java.lang``.

Ещё вопрос --- можно ли заимпортировать все классы из пакета, а не только один? Можно --- ``import java.lang.*;``. Другое дело, что в пакете может быть сотни классов, и тебе это просто не нужно.

*Ещё* вопрос --- а если заимпортировать ``java``? Ответ --- импорт * не рекурсивный. Он только классы из соответствующего пакета.  К примеру при ``import java.lang.*;`` у нас не будет классов из ``java.lang.zip``. Импортировать *пакеты* в Java --- нельзя!

Также импорт можно писать только в начале, перед определением ваших классов.

## Scanner и ДЗ

Класс ``Scanner`` предназначен для получения значений из строк.  (Но он может и другие использовать объекты для получения данных).
```java
Scanner sc = new Scanner("1 2 3 4");  
while (sc.hasNextInt()) {  
    System.out.println(sc.nextInt());  
}
```
```java
1 2 3 4 
```
Довольно интуитивно работающий класс, если что всегда можно почитать о нём в [документации](https://docs.oracle.com/javase/10/docs/api/java/util/Scanner.html).

 Вопрос --- если вы передадите куда-то сканнер, и он там что-то прочтет, то в основной функции, прочтет ли он это ещё раз или нет? Ответ --- нет. Реальный объект ``Scanner`` лежит где-то в памяти, где хранится его внутреннее состояние --- строчка, место в строчке и т.д. Много-много чего. Если мы передадим его ссылку еще куда-то, то при изменении внутреннего состояния по этой ссылке в другой ссылке внутреннее состояние тоже изменится. Это всё следствие того, что сканнер это ссылочный тип.

В Java в этом смысле все просто --- всё что не примитивы, это --- *ссылочный тип*.

Ну и в ДЗ нужно просто написать свой ``Scanner``. Ничего сложного правда? *Правда?*