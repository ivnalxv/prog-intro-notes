# Массивы и ссылки

Освежим знания прошлой лекции.
```java
public class ArrayExample {
	public static void main(String[] args) {
		int[] a;
		System.out.println(a);
	}
}
```
Данный код выдаст ошибку компиляции, так как в Java нельзя обращаться к переменным у которых нет значения.

Хорошо, давайте исправим.

```java
int[] a = new int[10];
```
Данный код выведет 
```java
[I@5b480cf9
```
Очевидно, напрямую sout не может вывести содержимое массива. Для этого можно воспользоваться циклом.
```java
int[] a = new int[10];
for (int i = 0; i < a.length; ++i) {
	System.out.println(a[i]);
}
```
На выходе мы получим
```
0 0 0 0 0 0 0 0 0 0 
```
Возникает вопрос --- всегда ли мы получим 0? Разные языки придерживаются разного мнения по данному вопросу. Java говорит, что при создании массива примитивного типа **все его элементы** инициализируются в каком-то смысле нулями.

Однако не у каждого примитивного типа есть разумный ноль. К примеру **boolean**. У этого типа есть два значения **true** и **false**, и значением по умолчанию считается **false**.

Окэй, что будет если мы проинициализируем массив строчек? 
>Предположение:  Это будет пустая строка. Однако пустая строка это не совсем простая штука. Для пустой строки компилятор должен знать что-то про тип строка, однако в Java это не так.

>В Java есть только одно место в котором специально упоминается тип String особый --- это то, что к нему можно прибавить все, что угодно, и это все, что угодно будет сконкатенировано.

Для строк мы получим **null**. Это специальное значение, обозначающее *ничего*. Но как это работает? Дело в том, что когда у нас есть строка, это на самом деле не строка, а ссылка на строку. 

Если у нас есть ``String str = "sadstring"``,  то в этом ``str`` строка не хранится ни в какой форме. Она хранится в памяти, а в ``str`` хранится ссылка на эту память.

Так вот, эта ссылка может указывать на *ничего*, говорящее, что никакой ссылки на самом деле нет. Вот это *ничего* и есть **null**.

Однако сразу же возникает множество вопросов. Сможете ли вы угадать, что выведет данный код?
```java
String[] a = new String[10];  
a[0] = "hello";  
a[1] = a[0];  
a[2] = "hello";  
a[4] = args[0]; // в args[0] передадим "hello". 
  
System.out.println(a[0] == a[1]);  
System.out.println(a[0] == a[2]);  
System.out.println(a[0] == a[3]);
```

Спойлер, будет ``true true false``. Это должно вызывать вопросы. Давайте помедитируем, почему в последнем будет не **true** . В первом элементе массива лежит ссылка на ``hello``. И во втором элементе лежит ссылка на ``hello``.  И в третьем элементе тоже.  Но некоторые из них равны, а некоторые нет. Что происходит? 

 1. В ``a[0]`` просто лежит ссылка на ``hello``. Это на самом деле константа, её положили в пулл констант.
 2.  Мы сказали, что ``a[1] = a[0]`` , поэтому оно будет указывать туда же.
 3. Теперь ``a[2]`` . Это было ``hello``, но другое. Однако, здесь произошел нетривиальный поворот --- Java умеет идентифицировать строчные константы, поэтому она не будет хранить две строчные константы с одинаковым ``hello``. Поэтому третий элемент указывает туда же куда и первый со вторым.
 4. Четвертую ссылку взяли из аргументов командной строки. Когда мы их парсим, об этом ``hello`` никто не знает. Это совершенно новое ``hello``, и они не совпадают.

Правила сравнения в Java такие: 

 - Оператор ``==`` сравнивает в Java элементы как ссылки. Если ссылки указывают в одно место, то они равны, если в разные, то нет.
 - Для проверки строчек на истинное равенство по содержимому. Для этого есть метод ``equals``. Он определен у всех классов, другое дело, он не у всех классов разумно работает.

Итого для ссылочных типов есть два типа равенства --- равенство ссылок и равенство значения.

У любого массива есть длина. Может ли она быть равна нулю?
```java
String[] a = new String[0];  
a[0] = "hello";
```

Правильный ответ может, другое дело, что наша программа сломается, так как мы попытаемся залезть в невыделенную нам память и получим **ArrayIndexOutOfBoundsException**.

Также мы можем создавать массив не заранее фиксированного размера. Здесь ``args.length`` --- не константа компиляции,.
```java
String[] a = new String[args.length];
```
А можем ли мы сделать так?
```java
String[] a = new String[-1];
```
Уже нет, так как не понятно, что такое массив с отрицательной длинной. **Заметьте, что это не ошибка компиляции, так как массивы создаются во время исполнения**.

Часто нам хочется задать массив ещё при создании. Тогда нам нужно написать так:
```java
String[] a = new String[] {
	"hello",
	"world",
	"!"
}
```

Теперь другой вопрос. Сможем ли мы сделать так?
```java
String[] a = new String[] {
	"hello",
	a[0],
	"!",
	args[0]
}
```
Нельзя, так как во время создания никакая переменная ``a`` еще не определена.

Теперь посмотрим на метод ``equals``. Заметим, что вот такой код выдаст ``true false``.
```java
String[] a = new String[] {  
        "hello",  
        null  
};  
System.out.println(a[0].equals("hello"));  
System.out.println(a[0].equals(null));
```

Существующие строчки не считают себя равными не существующим. Однако какое у нас мнение у **null** на эту тему?

```java
String s = null;
System.out.println(s.equals(null));
```
Java выдаст нам **NullPointerException**, так как мы пытаемся вызвать метод у *ничего*. (*Забавно*: Не смотря на то, что в Java везде используется обозначение **reference**, по историческим причинам это исключение называется **PointerException**.)

Дальше так как итерация по индексу для массива --- это очень частое действие, то для этого было создано сокращение:
```java
for (String s : a) {  
    System.out.println(s);  
}
```
Такой синтаксис называется ``foreach``.  Для массивов у нас всегда есть неявный индекс, просто в ``s`` всегда кладётся соответствующий элемент. В случае строчек это ссылка, в случае примитивного массива элемент.


## Двумерные массивы 

В отличии от одномерных, двумерные массивы инициализируются с помощью двух пар квадратных скобочек. Как вы наверное догадались, $n$-мерный массив инициализируются с помощью $n$ пар. 
```java
int[][] ints = new int[2][3];  
  
System.out.println(ints);  
for (int[] v : ints) {  
    System.out.println(v);  
}
```
