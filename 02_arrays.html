<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Массивы и ссылки - prog-intro-notes</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="chapter-item expanded "><a href="02_arrays.html" class="active"><strong aria-hidden="true">2.</strong> Массивы и ссылки</a></li><li class="chapter-item expanded "><a href="03_io_and_exceptions.html"><strong aria-hidden="true">3.</strong> Ввод-вывод и исключения</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">prog-intro-notes</h1>

                    <div class="right-buttons">
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="Массивы-и-ссылки"><a class="header" href="#Массивы-и-ссылки">Массивы и ссылки</a></h1>
<h2 id="Введение-в-массивы"><a class="header" href="#Введение-в-массивы">Введение в массивы</a></h2>
<p>Освежим знания прошлой лекции.</p>
<pre><code class="language-java">public class ArrayExample {
	public static void main(String[] args) {
		int[] a;
		System.out.println(a);
	}
}
</code></pre>
<p>Данный код выдаст ошибку компиляции, так как в Java нельзя обращаться к переменным у которых нет значения.</p>
<p>Хорошо, давайте исправим.</p>
<pre><code class="language-java">int[] a = new int[10];
System.out.println(a);
</code></pre>
<pre><code class="language-java">[I@5b480cf9
</code></pre>
<p>Очевидно, напрямую sout не может вывести содержимое массива. Для этого можно воспользоваться циклом.</p>
<pre><code class="language-java">int[] a = new int[10];
for (int i = 0; i &lt; a.length; ++i) {
	System.out.println(a[i]);
}
</code></pre>
<pre><code class="language-java">0 0 0 0 0 0 0 0 0 0 
</code></pre>
<p>Возникает вопрос — всегда ли мы получим 0? Разные языки придерживаются разного мнения по данному вопросу. Java говорит, что при создании массива примитивного типа <strong>все его элементы</strong> инициализируются в каком-то смысле нулями.</p>
<p>Однако не у каждого примитивного типа есть разумный ноль. К примеру <code>boolean</code>. У этого типа есть два значения <code>true</code> и <code>false</code>, и значением по умолчанию считается <code>false</code>.</p>
<p>Окэй, что будет если мы проинициализируем массив строчек? </p>
<blockquote>
<p>Предположение:  Это будет пустая строка. Однако пустая строка это не совсем простая штука. Для пустой строки компилятор должен знать что-то про тип строка, однако в Java это не так. В Java есть только одно место в котором специально упоминается тип String особый — это то, что к нему можно прибавить все, что угодно, и это все, что угодно будет сконкатенировано.</p>
</blockquote>
<p>Для строк мы получим <code>null</code>. Это специальное значение, обозначающее <em>ничего</em>. Но как это работает? Дело в том, что когда у нас есть строка, это на самом деле не строка, а ссылка на строку. </p>
<p>Если у нас есть <code>String str = &quot;sadstring&quot;</code>,  то в этом <code>str</code> строка не хранится ни в какой форме. Она хранится в памяти, а в <code>str</code> хранится ссылка на эту память.</p>
<p>Так вот, эта ссылка может указывать на <em>ничего</em>, говорящее, что никакой ссылки на самом деле нет. Вот это <em>ничего</em> и есть <code>null</code>.</p>
<p>Однако сразу же возникает множество вопросов. Сможете ли вы угадать, что выведет данный код?</p>
<pre><code class="language-java">String[] a = new String[10];  
a[0] = &quot;hello&quot;;  
a[1] = a[0];  
a[2] = &quot;hello&quot;;  
a[3] = args[0]; // в args[0] передадим &quot;hello&quot;. 
  
System.out.println(a[0] == a[1]);  
System.out.println(a[0] == a[2]);  
System.out.println(a[0] == a[3]);
</code></pre>
<pre><code class="language-java">true true false
</code></pre>
<p>Это должно вызывать вопросы. Давайте помедитируем, почему в последнем будет не <code>true</code> . В первом элементе массива лежит ссылка на <code>hello</code>. И во втором элементе лежит ссылка на <code>hello</code>.  И в третьем элементе тоже.  Но некоторые из них равны, а некоторые нет. Что происходит? </p>
<ol>
<li>В <code>a[0]</code> просто лежит ссылка на <code>hello</code>. Это на самом деле константа, её положили в пулл констант.</li>
<li>Мы сказали, что <code>a[1] = a[0]</code> , поэтому оно будет указывать туда же.</li>
<li>Теперь <code>a[2]</code> . Это было <code>hello</code>, но другое. Однако, здесь произошел нетривиальный поворот — Java умеет идентифицировать строчные константы, поэтому она не будет хранить две строчные константы с одинаковым <code>hello</code>. Поэтому третий элемент указывает туда же куда и первый со вторым.</li>
<li>Четвертую ссылку взяли из аргументов командной строки. Когда мы их парсим, об этом <code>hello</code> никто не знает. Это совершенно новое <code>hello</code>, и они не совпадают.</li>
</ol>
<p>Правила сравнения в Java такие: </p>
<ul>
<li>Оператор <code>==</code> сравнивает в Java элементы как ссылки. Если ссылки указывают в одно место, то они равны, если в разные, то нет.</li>
<li>Для проверки строчек на истинное равенство по содержимому есть метод <code>equals</code>. Он определён у всех классов, другое дело, он не у всех классов разумно работает.</li>
</ul>
<p>Итого для ссылочных типов есть два типа равенства — равенство ссылок и равенство значения.</p>
<p>У любого массива есть длина. Может ли она быть равна нулю?</p>
<pre><code class="language-java">String[] a = new String[0];  
a[0] = &quot;hello&quot;;
</code></pre>
<p>Правильный ответ — может, другое дело, что наша программа сломается, так как мы попытаемся залезть в невыделенную нам память и получим <strong>ArrayIndexOutOfBoundsException</strong>.</p>
<p>Также мы можем создавать массив не заранее фиксированного размера. Здесь <code>args.length</code> — не константа компиляции,.</p>
<pre><code class="language-java">String[] a = new String[args.length];
</code></pre>
<p>А можем ли мы сделать так?</p>
<pre><code class="language-java">String[] a = new String[-1];
</code></pre>
<p>Уже нет, так как не понятно, что такое массив с отрицательной длинной. <strong>Заметьте, что это не ошибка компиляции, так как массивы создаются во время исполнения</strong>.</p>
<p>Часто нам хочется задать массив ещё при создании. Тогда нам нужно написать так:</p>
<pre><code class="language-java">String[] a = new String[] {
	&quot;hello&quot;,
	&quot;world&quot;,
	&quot;!&quot;
}
</code></pre>
<p>Теперь другой вопрос. Сможем ли мы сделать так?</p>
<pre><code class="language-java">String[] a = new String[] {
	&quot;hello&quot;,
	a[0],
	&quot;!&quot;,
	args[0]
}
</code></pre>
<p>Нельзя, так как во время создания никакая переменная <code>a</code> еще не определена.</p>
<p>Теперь посмотрим на метод <code>equals</code>. </p>
<pre><code class="language-java">String[] a = new String[] {  
        &quot;hello&quot;,  
        null  
};  
System.out.println(a[0].equals(&quot;hello&quot;));  
System.out.println(a[0].equals(null));
</code></pre>
<pre><code class="language-java">true false
</code></pre>
<p>Существующие строчки не считают себя равными не существующим. Однако какое у нас мнение у <code>null</code> на эту тему?</p>
<pre><code class="language-java">String s = null;
System.out.println(s.equals(null));
</code></pre>
<p>Java выдаст нам <strong>NullPointerException</strong>, так как мы пытаемся вызвать метод у <em>ничего</em>. (<em>Забавно</em>: Не смотря на то, что в Java везде используется обозначение <strong>reference</strong>, по историческим причинам это исключение называется <strong>PointerException</strong>.)</p>
<p>Дальше так как итерация по индексу для массива — это очень частое действие, то для этого было создано сокращение:</p>
<pre><code class="language-java">for (String s : a) {  
    System.out.println(s);  
}
</code></pre>
<p>Такой синтаксис называется <code>foreach</code>.  Для массивов у нас всегда есть неявный индекс, просто в <code>s</code> всегда кладётся соответствующий элемент. В случае строчек это ссылка, в случае примитивного массива элемент.</p>
<h2 id="Двумерные-массивы"><a class="header" href="#Двумерные-массивы">Двумерные массивы</a></h2>
<p>В отличии от одномерных, двумерные массивы инициализируются с помощью двух пар квадратных скобочек. Как вы наверное догадались, //(n//)-мерный массив инициализируются с помощью //(n//) пар. </p>
<pre><code class="language-java">int[][] ints = new int[2][3];  
  
System.out.println(ints);  
for (int[] v : ints) {  
    System.out.println(v);  
}
</code></pre>
<p>На самом деле в Java двухмерный массив — это всего-навсего куча ссылок на одномерные массивы. Мы можем в этом убедиться сделав частично инициализированный массив.</p>
<pre><code class="language-java">int[][] ints = new int[10][];  

System.out.println(ints,length);
for (int[] row : ints) {
	System.out.println(row); 
    for (int elem : row) {
		System.out.print(elem + &quot; &quot;);
	}
	System.out.println();
}
</code></pre>
<p>В результате в консоль выведется <code>10 null</code>, а потом вылетит исключение, так как мы пытаемся итерироваться по <code>null</code>. Это значит, что <code>row</code> — это честная ссылка. Отсюда следует, что двумерный массив не обязан быть прямоугольным, так как <code>ints[i]</code>  это всего лишь ссылка на какой-то массив, без какого-то ограничения на длину. Может быть что-то вроде такого:</p>
<pre><code class="language-java">ints[][] a = new int[][]{
	{1, 2, 3, 4},
	{1, 2},
	{0, 1, 3} 
};
</code></pre>
<p>Но вот так уже сделать нельзя:</p>
<pre><code class="language-java">int[][] ints = new int[][10];  
</code></pre>
<h2 id="Сравнение-массивы-как-ссылки"><a class="header" href="#Сравнение-массивы-как-ссылки">Сравнение, массивы как ссылки</a></h2>
<p>Массивы можно сравнивать. Во первых их можно сравнить на <code>==</code>. Если это одна и та же ссылка, то ок, иначе нет. Метод <code>equals</code> на массивах работает <strong>точно также</strong>, как и <code>==</code> по определению. Он не будет проверять на равенство элементов.</p>
<p>Так как массивы это по сути ссылки на элементы, то при приравнивании массивов, мы просто будем ссылаться на ту же память.</p>
<pre><code class="language-java">int[] a = new int[] {1, 2, 3, 4};
int[] b = a;   
System.out.println(a == b);
b[0] = 100;
System.out.print(a[0] + &quot; &quot; + b[0]);
</code></pre>
<pre><code class="language-java">true 100 100
</code></pre>
<p>Ожидаемый результат, так как это ссылки. Но у нас возникает проблема:</p>
<pre><code class="language-java">int[] a = new int[] {1, 2, 3, 4};  
int[] b = new int[] {1, 2, 3, 4};  
System.out.println(a == b);  
System.out.println(a.equals(b));
</code></pre>
<pre><code class="language-java">false false
</code></pre>
<p>Но так как это ссылки, то два массива с одинаковыми элементами, но разной памятью будут не равны!  Именно поэтому нужно быть аккуратным.</p>
<h2 id="Функции-и-массивы"><a class="header" href="#Функции-и-массивы">Функции и массивы</a></h2>
<p>Давайте заведём функцию <code>dump()</code>:</p>
<pre><code class="language-java">public static void dump(int[] ints) {  
    for (int v : ints) {  
        System.out.print(v + &quot; &quot;);  
    }  
    System.out.println();  
}
</code></pre>
<p>Что же мы передаем в функцию <code>dump()</code>? Как вы уже наверное догадались, мы передаем <em>ссылку</em> на массив. Давайте теперь провернем фокус:</p>
<pre><code class="language-java">public static void change1(int[] ints) {  
    ints = new int[] {-1, 0};
    dump(ints);
}

public static void change2(int[] ints) {  
    ints[0] = -1;
    dump(ints);
}

public static void main(String[] args) {  
    int[] a = new int[] {1, 2, 3, 4}; 
    int[] b = new int[] {1, 2, 3, 4}; 
    change1(a);
    dump(a);
    System.out.println(&quot;========&quot;);
    change2(b);
    dump(b);
}
</code></pre>
<pre><code class="language-java">-1 0 
1 2 3 4 
========
-1 2 3 4 
-1 2 3 4 
</code></pre>
<p>Что же тут произошло? Давайте разбираться!
Мы передаём ссылку в <code>change1()</code>. Дальше мы создаем новый массив и наша ссылка начинает указывать на совершенно новое место в памяти. Оно никак не связано со старым, поэтому <code>a</code> никак не меняется.</p>
<p>Перед тем как поговорить про то, что происходит в <code>change2()</code>, давайте поговорим про типы передачи данных в языках программирования. Есть два основных типа передачи:</p>
<ol>
<li>По значению (<em>by value</em>). При передаче по значению, создаётся копия передаваемого аргумента. Это независимая копия, другая память.</li>
<li>По ссылке (<em>by reference</em>). В таком случае передаётся ссылка на аргумент — это то же самое место в памяти, поэтому если вы меняете что-то переданное <em>by reference</em> исходники изменяются.</li>
</ol>
<p>В Java аргументы всегда передаются по значению. Поэтому когда мы передаём ссылку в <code>change2()</code>, то мы получаем <em>копию ссылки</em>. Однако эта копия всё ещё указывает на то же место в памяти, что и оригинал. Поэтому, когда мы меняем какой-то элемент <code>ints</code>, то мы меняем память принадлежащую массиву <code>b</code>.</p>
<p>Это значит, что на один и тот же объект может быть множество ссылок. Иногда можно словить с этим проблему:</p>
<pre><code class="language-java">public static void change(int[] x, int[] y) {  
    x[0] = y[1];  
    x[1] = y[0];  
}  
  
public static void main(String[] args) {  
    int[] a = new int[] {10, 30};  
    change(a, a);  
    dump(a);  
}
</code></pre>
<pre><code class="language-java">30 30
</code></pre>
<p>Что здесь произошло? Программист не учел, что в функцию <code>change()</code> мы можем запихнуть один и тот же массив, и в результате произошла ошибка. С этим нужно быть аккуратным. Это называется <strong>Aliasing</strong> — когда два, вроде независимых объекта, ссылаются на одно и то же место в памяти. Если они ссылаются на что-то неизменяемое, то все отлично, это никак не может навредить нам ни при каких условиях. Если же там можно что-то поменять, то у вас может возникнуть проблема. Что делать? С этим нужно просто научиться жить 🙂.</p>
<p>Давайте посмотрим на следующий код:</p>
<pre><code class="language-java">public static int[] create(int value, int len) {  
    int[] result = new int[len];  
    for (int i = 0; i &lt; len; ++i) {  
        result[i] = value;  
    }
    return result;  
}
</code></pre>
<p>Код создаст нам массив длины <code>len</code>, состоящий из <code>value</code>. Заметим, что <code>foreach</code> цикл здесь не подойдет, так как мы каждый раз получаем копию элемента, а не ссылку на него. </p>
<p>Однако вот такой код уже сработает:</p>
<pre><code class="language-java">Vector[] result = new Vector[] {  
        new Vector(0, 0),  
        new Vector(-40, 30),  
        new Vector(8, 4)  
};  
for (Vector s : result) {  
    s.plus(new Vector(5, -5));  
}  
for (int i = 0; i &lt; result.length; ++i) {  
    System.out.println(result[i]);  
}
</code></pre>
<pre><code class="language-java">Vector{x=5.0, y=-5.0}
Vector{x=-35.0, y=25.0}
Vector{x=13.0, y=-1.0}
</code></pre>
<h2 id="Копия-элементов-systemarraycopy"><a class="header" href="#Копия-элементов-systemarraycopy">Копия элементов, System.arraycopy(...)</a></h2>
<pre><code class="language-java">int[] a = create(10, 5);  
a[1] = 100;  
int[] b = new int[] {0, 10, 20, 30, 40, 50};  
dump(a);  
dump(b);  
System.arraycopy(a, 1, b, 2, 3);  
dump(b);
</code></pre>
<pre><code class="language-java">10 100 10 10 10 
0 10 20 30 40 50 
0 10 100 10 10 50 
</code></pre>
<p>Для <code>System.arraycopy(a, b, c, d, e)</code> первым параметром является <strong>массив источник</strong>, вторым — <strong>позиция его начала массива</strong>, третьим — <strong>массив назначение</strong>, четвертым — <strong>позиция уже его начала</strong>, пятым — <strong>сколько элементов</strong>.  (Или можно нормально прочитать в <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int)">доках</a>) </p>
<p>Заметим, что если это массив <strong>ссылочного</strong> типа, то будут копироваться <em>ссылки</em>, а не значения. Также, если ввести больше чем есть элементов, то получим <strong>ArrayIndexOutOfBoundsException</strong>.</p>
<h2 id="Дерево-пакетов"><a class="header" href="#Дерево-пакетов">Дерево пакетов</a></h2>
<p>Как мы уже говорили в начале лекции, хотелось бы уметь выводить массивы. Для этого есть специальный метод!</p>
<pre><code class="language-java">int[] a = create(10, 5);  
System.out.println(java.util.Arrays.toString(a));
</code></pre>
<pre><code class="language-java">[10, 10, 10, 10, 10]
</code></pre>
<p>Даже больше, можно написать вот так!</p>
<pre><code class="language-java">int[] a = create(10, 5);  
java.lang.System.out.println(java.util.Arrays.toString(a));
</code></pre>
<pre><code class="language-java">[10, 10, 10, 10, 10]
</code></pre>
<p>Но, прямо скажем, писать всё это очень запарно. В принципе, в этом нет ничего плохого, просто писать так — не удобно. Так вот, что на самом деле здесь происходит: в Java есть, так называемое <strong>Дерево пакетов</strong>. Это реально дерево, в нем есть пакеты, а в пакетах есть классы и другие пакеты.</p>
<p>Что тут происходит? Сейчас мы знаем, что есть пакет <code>java</code>, в нём пакет <code>lang</code>, а в нём класс <code>System</code>. К примеру, в этом же пакете <code>lang</code> находится <code>String</code>, а вот <code>Arrays</code> уже находится не в пакете <code>lang</code>, а в пакете <code>util</code>.</p>
<p>В целом, в <code>lang</code> обычно находятся всякие основные, стандартизированные классы, в <code>util</code> всякие разные полезные классы. Дерево не обязательно глубины два — к примеру есть пакет <code>java.util.zip</code>.</p>
<p>Возникают вопросы — это конечно хорошо, что вместо <code>java.lang.System</code> можем просто писать <code>System</code>, а можем ли мы вместо <code>java.util.Arrays</code> просто писать <code>Arrays</code>? Можем, но для этого нам нужно в явной форме импортировать:</p>
<pre><code class="language-java">import java.util.Arrays;  
  
public class ArrayExample {  
    public static void main(String[] args) {  
        int[] a = new int[] {1, 2, 3};  
        java.lang.System.out.println(Arrays.toString(a));  
    }  
}
</code></pre>
<p>Правда опять возникает вопрос — почему для <code>Arrays</code> нужен импорт, а для всего остального не надо? <strong>Потому что в спецификации написано, что в начале каждой программы импортируется все из <code>java.lang</code></strong>. Просто прикол пакета <code>java.lang</code>.</p>
<p>Ещё вопрос — можно ли заимпортировать все классы из пакета, а не только один? Можно — <code>import java.lang.*;</code>. Другое дело, что в пакете может быть сотни классов, и тебе это просто не нужно.</p>
<p><em>Ещё</em> вопрос — а если заимпортировать <code>java</code>? Ответ — импорт * не рекурсивный. Он только классы из соответствующего пакета.  К примеру при <code>import java.lang.*;</code> у нас не будет классов из <code>java.lang.zip</code>. Импортировать <em>пакеты</em> в Java — нельзя!</p>
<p>Также импорт можно писать только в начале, перед определением ваших классов.</p>
<h2 id="scanner-и-ДЗ"><a class="header" href="#scanner-и-ДЗ">Scanner и ДЗ</a></h2>
<p>Класс <code>Scanner</code> предназначен для получения значений из строк.  (Но он может и другие использовать объекты для получения данных).</p>
<pre><code class="language-java">Scanner sc = new Scanner(&quot;1 2 3 4&quot;);  
while (sc.hasNextInt()) {  
    System.out.println(sc.nextInt());  
}
</code></pre>
<pre><code class="language-java">1 2 3 4 
</code></pre>
<p>Довольно интуитивно работающий класс, если что всегда можно почитать о нём в <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Scanner.html">документации</a>.</p>
<p>Вопрос — если вы передадите куда-то сканнер, и он там что-то прочтет, то в основной функции, прочтет ли он это ещё раз или нет? Ответ — нет. Реальный объект <code>Scanner</code> лежит где-то в памяти, где хранится его внутреннее состояние — строчка, место в строчке и т.д. Много-много чего. Если мы передадим его ссылку еще куда-то, то при изменении внутреннего состояния по этой ссылке в другой ссылке внутреннее состояние тоже изменится. Это всё следствие того, что сканнер это ссылочный тип.</p>
<p>В Java в этом смысле все просто — всё что не примитивы, это — <em>ссылочный тип</em>.</p>
<p>Ну и в ДЗ нужно просто написать свой <code>Scanner</code>. Ничего сложного правда? <em>Правда?</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="01_intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="03_io_and_exceptions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="01_intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="03_io_and_exceptions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
    </body>
</html>
